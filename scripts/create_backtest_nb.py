
import nbformat as nbf
import os

def create_backtest_notebook():
    nb = nbf.v4.new_notebook()
    
    # Markdown - Title
    nb.cells.append(nbf.v4.new_markdown_cell(
        "# 地方競馬（NAR）収支シミュレーション (18モデル)\n\n"
        "最強モデル (NB17: Pedigree + Bias + Advanced features) を用いて、実際の回収率シミュレーション（バックテスト）を行います。\n\n"
        "### 検証内容\n"
        "- **対象**: テストデータ期間 (直近20%)\n"
        "- **賭け式**: 単勝 (Win) および 複勝 (Place)\n"
        "- **戦略**: \n"
        "    1. **Top-1 Flat**: 予測スコア1位の馬に均等賭け (100円)\n"
        "    2. **Top-1 Kelly**: 予測確率（スコア）に応じた資金配分 (簡易版)\n"
        "- **評価指標**: 回収率 (Return on Investment, ROI), 的中率, 純利益"
    ))
    
    # Code - Setup
    nb.cells.append(nbf.v4.new_code_cell(
        "import sys\n"
        "import os\n"
        "import pandas as pd\n"
        "import numpy as np\n"
        "import lightgbm as lgb\n"
        "import seaborn as sns\n"
        "import matplotlib.pyplot as plt\n"
        "import japanize_matplotlib\n"
        "from tqdm.auto import tqdm\n\n"
        "# プロジェクトのsrcディレクトリをパスに追加\n"
        "src_path = os.path.abspath(os.path.join(os.getcwd(), '../../src'))\n"
        "if src_path not in sys.path:\n"
        "    sys.path.append(src_path)\n\n"
        "from nar.loader import NarDataLoader\n"
        "from nar.features import NarFeatureGenerator\n\n"
        "%matplotlib inline\n"
        "sns.set(font='IPAexGothic', style='whitegrid')"
    ))
    
    # Code - Data Load & Model Train (NB17 Copy)
    nb.cells.append(nbf.v4.new_code_cell(
        "# --- モデル構築 (NB17相当) ---\n"
        "loader = NarDataLoader()\n"
        "raw_df = loader.load(limit=200000, region='south_kanto')\n\n"
        "generator = NarFeatureGenerator(history_windows=[1, 2, 3, 4, 5])\n"
        "df = generator.generate_features(raw_df)\n\n"
        "df = df.dropna(subset=['rank']).copy()\n"
        "df['date'] = pd.to_datetime(df['date'])\n\n"
        "# 特徴量定義 (NB17)\n"
        "baseline_features = [\n"
        "    'distance', 'venue', 'state', 'frame_number', 'horse_number', 'weight', 'impost',\n"
        "    'jockey_win_rate', 'jockey_place_rate', 'trainer_win_rate', 'trainer_place_rate',\n"
        "    'horse_run_count'\n"
        "] + [col for col in df.columns if 'horse_prev' in col]\n\n"
        "advanced_features = [\n"
        "    'gender', 'age', 'days_since_prev_race', 'weight_diff',\n"
        "    'horse_jockey_place_rate', 'is_consecutive_jockey',\n"
        "    'distance_diff', 'horse_venue_place_rate',\n"
        "    'trainer_30d_win_rate',\n"
        "    'impost_diff', 'was_accident_prev1', 'weighted_si_momentum', 'weighted_rank_momentum',\n"
        "    'class_rank', 'class_diff', 'is_promoted', 'is_demoted'\n"
        "]\n\n"
        "phase9_features = [\n"
        "    'weighted_si_momentum_race_rank', 'weighted_si_momentum_diff_from_avg', 'weighted_si_momentum_zscore',\n"
        "    'weighted_rank_momentum_race_rank', 'weighted_rank_momentum_diff_from_avg', 'weighted_rank_momentum_zscore',\n"
        "    'class_rank_race_rank', 'class_rank_diff_from_avg', 'class_rank_zscore',\n"
        "    'horse_state_place_rate', 'season', 'is_night_race', 'trainer_momentum_bias'\n"
        "]\n\n"
        "pedigree_features = [\n"
        "    'sire_win_rate', 'sire_place_rate'\n"
        "]\n\n"
        "track_bias_features = [\n"
        "    'track_bias_inner_win_rate', 'track_bias_outer_win_rate', 'track_bias_front_win_rate'\n"
        "]\n\n"
        "features = list(set(baseline_features + advanced_features + phase9_features + track_bias_features + pedigree_features))\n"
        "features = [f for f in features if f in df.columns]\n\n"
        "# 型変換\n"
        "categorical_cols = ['venue', 'state', 'gender', 'season']\n"
        "for col in features:\n"
        "    if col in categorical_cols:\n"
        "        df[col] = df[col].astype(str).astype('category')\n"
        "    else:\n"
        "        df[col] = pd.to_numeric(df[col], errors='coerce').astype(float)\n\n"
        "split_date = df['date'].quantile(0.8)\n"
        "train_df = df[df['date'] < split_date].sort_values('race_id').copy()\n"
        "test_df = df[df['date'] >= split_date].sort_values('race_id').copy()\n\n"
        "print(f'Train: {len(train_df)}, Test: {len(test_df)}')"
    ))
    
    # Code - Train
    nb.cells.append(nbf.v4.new_code_cell(
        "params = {\n"
        "    'objective': 'lambdarank',\n"
        "    'metric': 'ndcg',\n"
        "    'ndcg_at': [1, 3, 5],\n"
        "    'n_estimators': 1000,\n"
        "    'learning_rate': 0.05,\n"
        "    'num_leaves': 64,\n"
        "    'max_depth': 6,\n"
        "    'random_state': 42,\n"
        "    'importance_type': 'gain'\n"
        "}\n\n"
        "train_groups = train_df.groupby('race_id').size().values\n"
        "test_groups = test_df.groupby('race_id').size().values\n"
        "train_label = 20 - train_df['rank']\n"
        "test_label = 20 - test_df['rank']\n\n"
        "model = lgb.LGBMRanker(**params)\n"
        "model.fit(\n"
        "    train_df[features], train_label,\n"
        "    group=train_groups,\n"
        "    eval_set=[(test_df[features], test_label)],\n"
        "    eval_group=[test_groups],\n"
        "    eval_at=[1, 3, 5],\n"
        "    callbacks=[lgb.early_stopping(stopping_rounds=50)]\n"
        ")\n"
        "test_df['pred_score'] = model.predict(test_df[features])"
    ))
    
    # Code - Payout Data Load
    nb.cells.append(nbf.v4.new_code_cell(
        "# 払戻金データの取得 (テスト期間の日付ごとに取得)\n"
        "test_dates = test_df['date'].unique()\n"
        "payouts_all = []\n"
        "print('Loading payout data...')\n"
        "for d in tqdm(test_dates):\n"
        "    date_str = pd.Timestamp(d).strftime('%Y-%m-%d')\n"
        "    payouts = loader.load_payouts(date_str)\n"
        "    payouts_all.append(payouts)\n\n"
        "payouts_df = pd.concat(payouts_all, ignore_index=True)\n"
        "print(f'Payout Data: {len(payouts_df)} records')"
    ))
    
    # Code - Simulation Logic
    nb.cells.append(nbf.v4.new_code_cell(
        "# シミュレーション用データの作成\n"
        "# race_id ごとのTop1予測馬を抽出\n"
        "test_df['pred_rank'] = test_df.groupby('race_id')['pred_score'].rank(method='min', ascending=False)\n"
        "top1_preds = test_df[test_df['pred_rank'] == 1].copy()\n"
        "\n"
        "# 払戻金と結合\n"
        "merged = top1_preds.merge(payouts_df, on='race_id', how='inner')\n"
        "\n"
        "# 単勝 (Win) 計算\n"
        "# payout_win_horse_1 が勝ち馬番号\n"
        "def calc_win_return(row):\n"
        "    bet_amount = 100\n"
        "    ret = 0\n"
        "    # 1着が同着の場合などがどう入るかによるが、基本は _1 を見る\n"
        "    if row['payout_win_horse_1'] is not None:\n"
        "        try:\n"
        "            win_horse = int(row['payout_win_horse_1'])\n"
        "            if int(row['horse_number']) == win_horse:\n"
        "                ret = int(row['payout_win_amount_1'])\n"
        "        except:\n"
        "            pass\n"
        "    return ret - bet_amount\n\n"
        "merged['win_balance'] = merged.apply(calc_win_return, axis=1)\n"
        "merged['win_cumsum'] = merged['win_balance'].cumsum()\n\n"
        "# 複勝 (Place) 計算\n"
        "def calc_place_return(row):\n"
        "    bet_amount = 100\n"
        "    ret = 0\n"
        "    # 3着まで見る\n"
        "    h_num = int(row['horse_number'])\n"
        "    try:\n"
        "        if row['payout_place_horse_1'] is not None and int(row['payout_place_horse_1']) == h_num:\n"
        "            ret = int(row['payout_place_amount_1'])\n"
        "        elif row['payout_place_horse_2'] is not None and int(row['payout_place_horse_2']) == h_num:\n"
        "            ret = int(row['payout_place_amount_2'])\n"
        "        elif row['payout_place_horse_3'] is not None and int(row['payout_place_horse_3']) == h_num:\n"
        "            ret = int(row['payout_place_amount_3'])\n"
        "    except:\n"
        "        pass\n"
        "    return ret - bet_amount\n\n"
        "merged['place_balance'] = merged.apply(calc_place_return, axis=1)\n"
        "merged['place_cumsum'] = merged['place_balance'].cumsum()"
    ))
    
    # Code - Visualization
    nb.cells.append(nbf.v4.new_code_cell(
        "# 結果表示\n"
        "total_races = len(merged)\n"
        "win_profit = merged['win_balance'].sum()\n"
        "place_profit = merged['place_balance'].sum()\n"
        "win_roi = (win_profit + total_races * 100) / (total_races * 100) * 100\n"
        "place_roi = (place_profit + total_races * 100) / (total_races * 100) * 100\n"
        "win_rate = (merged['win_balance'] > 0).mean() * 100\n"
        "place_rate = (merged['place_balance'] > 0).mean() * 100\n\n"
        "print(f'総レース数: {total_races} (1点100円)')\n"
        "print(f'【単勝】 収支: {win_profit}円, 回収率: {win_roi:.1f}%, 的中率: {win_rate:.1f}%')\n"
        "print(f'【複勝】 収支: {place_profit}円, 回収率: {place_roi:.1f}%, 的中率: {place_rate:.1f}%')\n\n"
        "plt.figure(figsize=(12, 6))\n"
        "plt.plot(merged['win_cumsum'], label='Win (Tansho)')\n"
        "print(f'【複勝】 収支: {place_profit}円, 回収率: {place_roi:.1f}%, 的中率: {place_rate:.1f}%')\n\n"
        "# --- [NEW] 期待値フィルタシミュレーション ---\n"
        "# 1. Softmaxで予測確率 (Prob) を算出\n"
        "from scipy.special import softmax\n"
        "def calc_prob(df_group):\n"
        "    df_group['pred_prob'] = softmax(df_group['pred_score'])\n"
        "    return df_group\n"
        "test_df = test_df.groupby('race_id', group_keys=False).apply(calc_prob)\n"
        "\n"
        "# 2. 期待値 (EV) = Prob * Odds\n"
        "# mergeのために pred_prob を merged に結合する必要がある\n"
        "# ここでは merged は top1_preds なので、top1 の prob だけあればよい\n"
        "merged = merged.merge(test_df[['race_id', 'horse_number', 'pred_prob']], on=['race_id', 'horse_number'], how='left')\n"
        "merged['expected_value'] = merged['pred_prob'] * merged['odds']\n\n"
        "# 3. フィルタリング (EV >= 1.0)\n"
        "ev_mask = merged['expected_value'] >= 1.0\n"
        "ev_filtered = merged[ev_mask].copy()\n"
        "ev_total = len(ev_filtered)\n"
        "if ev_total > 0:\n"
        "    ev_win_balance = ev_filtered['win_balance'].sum()\n"
        "    ev_roi = (ev_win_balance + ev_total * 100) / (ev_total * 100) * 100\n"
        "    ev_win_rate = (ev_filtered['win_balance'] > 0).mean() * 100\n"
        "    print('-' * 40)\n"
        "    print(f'【条件付】 期待値(EV) >= 1.0 のみ購入')\n"
        "    print(f'購入レース数: {ev_total} / {total_races} ({ev_total/total_races*100:.1f}%)')\n"
        "    print(f'収支: {ev_win_balance}円, 回収率: {ev_roi:.1f}%, 的中率: {ev_win_rate:.1f}%')\n"
        "else:\n"
        "    print('該当するレースがありません。')\n\n"
        "plt.figure(figsize=(12, 6))\n"
        "plt.plot(merged['win_cumsum'], label='All (Win)')\n"
        "plt.plot(merged[ev_mask]['win_balance'].cumsum().reset_index(drop=True), label='EV>=1.0 (Win)')\n"
        "plt.axhline(0, color='red', linestyle='--')\n"
        "plt.title('Backtest: All vs EV>=1.0 (Win)')\n"
        "plt.xlabel('Bet Count')\n"
        "plt.ylabel('Profit (JPY)')\n"
        "plt.legend()\n"
        "plt.grid(True)\n"
        "plt.show()"
    ))

    # Save
    path = '/workspace/notebooks/nar/18_nar_backtest_simulation.ipynb'
    with open(path, 'w', encoding='utf-8') as f:
        nbf.write(nb, f)
    print(f'Notebook created at {path}')

if __name__ == '__main__':
    create_backtest_notebook()
